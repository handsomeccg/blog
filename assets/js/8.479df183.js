(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{363:function(e,t,r){"use strict";r.r(t);var s=r(42),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),r("p",[e._v("定义：promise表示一个异步操作，promise的状态代表异步操作的状态\n特点：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("对象的状态不受外界影响：Promise有三种状态，pending、fulfilled和rejected。")])]),e._v(" "),r("li",[r("p",[e._v("状态一旦改变，就不会再变。")])]),e._v(" "),r("li",[r("p",[e._v("Promise rejected()的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch并不能捕获该错误。")])])]),e._v(" "),r("p",[e._v("then方法：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Promise.prototype.then()方法返回一个新的promise实例：\n如果没有提供resolve处理程序，则返回Promise.resolve()包装上一个promise解决之后的值（没有就是undefined） "),r("br"),e._v("\n如果resolve处理程序有显式的返回值，则返回 包装这个值的Promise.resolve() "),r("br")])]),e._v(" "),r("li",[r("p",[e._v("抛出异常会返回rejected的promise。返回一个错误对象不会触发reject方法，而会把错误对象包装在resolved的promise中。"),r("br"),e._v("\nPromise.rejected()调用then()时不传处理程序则原样向后传。")])]),e._v(" "),r("li",[r("p",[e._v("promise.finally()被设计为一个状态无关的方法，所以在大多数情况下它将表现为父promise的传递")])])]),e._v(" "),r("h3",{attrs:{id:"map"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),r("p",[e._v("Map和Object:")]),e._v(" "),r("ul",[r("li",[e._v("map的键可以是任意属性，object只能是string和symbol")]),e._v(" "),r("li",[e._v("map可以进行迭代；")]),e._v(" "),r("li",[e._v("map在频繁增删键值对的场景下表现更好。")])]),e._v(" "),r("h3",{attrs:{id:"title3-01"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#title3-01"}},[e._v("#")]),e._v(" title3-01")]),e._v(" "),r("h2",{attrs:{id:"small-title"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#small-title"}},[e._v("#")]),e._v(" small title")]),e._v(" "),r("p",[e._v("content...")])])}),[],!1,null,null,null);t.default=i.exports}}]);