(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{364:function(t,a,r){"use strict";r.r(a);var _=r(42),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"五层模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#五层模型"}},[t._v("#")]),t._v(" 五层模型")]),t._v(" "),r("ul",[r("li",[t._v("应用层：为应用提供接口服务等(HTTP/FTP协议)")]),t._v(" "),r("li",[t._v("传输层：定义传输数据的协议(TCP/UDP)。")]),t._v(" "),r("li",[t._v("网络层：端到端的包传输，主机的链接，ip寻址(ip协议)。")]),t._v(" "),r("li",[t._v("数据链路层：将网络层的ip数据封装成帧，每个帧包括数据和控制信息(地址信息，差错控制等)")]),t._v(" "),r("li",[t._v("物理层：定义物理设备标准,如网线接口，光纤接口类型。它的主要作用是传输比特流。")])]),t._v(" "),r("h2",{attrs:{id:"浏览器中输入url-回车后发生了什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中输入url-回车后发生了什么"}},[t._v("#")]),t._v(" 浏览器中输入url，回车后发生了什么")]),t._v(" "),r("p",[t._v("查看请求资源是否有缓存，如果有强制缓存则直接使用缓存。"),r("br"),t._v("\n如果是协商缓存则发起请求，校验缓存是否可用。"),r("br"),t._v("\n(Expires和Cache-Control这两个HTTP头来判断。Expires的值为一个绝对时间表示缓存过期时间；Cache-Control:max-age=，值为以秒为单位的缓存有效时间。)")]),t._v(" "),r("p",[t._v("DNS解析，查找过程：1.浏览器缓存；2.本地缓存；3.hosts文件；4.路由器缓存；5.DNS根服务器查询")]),t._v(" "),r("p",[t._v("端口建立TCP连接："),r("br"),t._v("\n1.客户端发送 SYN=1, Seq=X的包到服务器端口   客户端：SYN_SENT  服务端：SYN_RECEIVED  "),r("br"),t._v("\n2.服务器发送 SYN=1, ACK=X+1, Seq=Y 的响应包  客户端：ESTABLISHED  服务端：SYN_RECEIVED  "),r("br"),t._v("\n3.客户端发送 ACK=Y+1, Seq=Z 的响应包  客户端：ESTABLISHED  服务端：ESTABLISHED  "),r("br")]),t._v(" "),r("p",[t._v("建立TCP连接后发送HTTP请求"),r("br"),t._v("\n服务器接收请求返回相应的响应数据"),r("br"),t._v("\n首先会判断相应的状态码是多少，400或500就报错，300会进行重定向，200则继续解析"),r("br"),t._v("\n浏览器拿到请求的内容开始解析文件，如果是gzip格式会先解压，然后通过文件的编码格式决定如何解码文件。"),r("br"),t._v("\n文件解码后，开始渲染页面："),r("br"),t._v("\n根据html构建DOM树，根据css构建cssOM树，中间遇到script标签，会判断是否是异步执行（async/defer）"),r("br"),t._v("\nasync会并行下载执行js，不会影响当前解析，不保证执行顺序"),r("br"),t._v("\ndefer会先下载文件，等到html解析完成后再顺序执行"),r("br")]),t._v(" "),r("p",[t._v("若没有这两个标签，会阻塞渲染，等待脚本同步执行完成"),r("br")]),t._v(" "),r("p",[t._v("CSSOM树和DOM树构建完成后会开始生成渲染树，浏览器调用GPU绘制，合成图层，绘制内容到页面上"),r("br")]),t._v(" "),r("h2",{attrs:{id:"tcp-4次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp-4次挥手"}},[t._v("#")]),t._v(" TCP 4次挥手")]),t._v(" "),r("p",[t._v("1.客户端向服务端发送释放连接请求 FIN  客户端：FIN_WAIT_1 服务端：ESTABLISHED  "),r("br"),t._v("\n2.服务端收到请求，向客户端发送ACK包，服务端进入CLOSE_WAIT状态，不再接收客户端的数据。但服务端仍旧可以发送数据给客户端。 "),r("br"),t._v("\n3.服务端发送完剩下的数据，完毕后向客户端发送释放连接请求，服务端进入 LAST_ACK状态。"),r("br"),t._v("\n4.客户端收到释放连接请求后，向服务端发送确认应答，客户端进入TIME_WAIT阶段，该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间。若这个时间段内没有收到服务端的重发请求，则进入CLOSED状态。服务端收到确认应答后，也进入CLOSED状态。")]),t._v(" "),r("h2",{attrs:{id:"http"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),r("h3",{attrs:{id:"get和post"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get和post"}},[t._v("#")]),t._v(" get和post")]),t._v(" "),r("p",[t._v("1.get请求在浏览器回退时是无害的，post则会再次请求。\n2.get请求可以缓存，post不能\n3.get请求数据包含在url中，post请求数据在request body，存储的数据可以更多\n4.get多用于不改变资源的请求，post反之")]),t._v(" "),r("h3",{attrs:{id:"常见状态码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[t._v("#")]),t._v(" 常见状态码")]),t._v(" "),r("h4",{attrs:{id:"_1xx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1xx"}},[t._v("#")]),t._v(" 1XX")]),t._v(" "),r("p",[t._v("指示信息，表示请求已接收，继续处理")]),t._v(" "),r("h4",{attrs:{id:"_2xx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2xx"}},[t._v("#")]),t._v(" 2XX")]),t._v(" "),r("p",[t._v("200：请求成功"),r("br"),t._v("\n201：通常指POST请求的结果，已在服务器上成功创建了一个或多个资源"),r("br"),t._v("\n202：请求已接收处理，但处理尚未完成"),r("br"),t._v("\n204：请求成功，但相应报文不包含实体部分"),r("br"),t._v("\n206：请求成功，并且主体包含的数据区间是请求的Range首部指定的"),r("br")]),t._v(" "),r("h4",{attrs:{id:"_3xx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3xx"}},[t._v("#")]),t._v(" 3XX")]),t._v(" "),r("p",[t._v("301: 永久重定向"),r("br"),t._v("\n302：临时重定向"),r("br"),t._v("\n304：缓存可用，未修改（自从上次请求后，请求的网页未修改过）"),r("br")]),t._v(" "),r("h4",{attrs:{id:"_4xx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4xx"}},[t._v("#")]),t._v(" 4XX")]),t._v(" "),r("p",[t._v("400：请求报文存在语法错误"),r("br"),t._v("\n401：请求未授权"),r("br"),t._v("\n403：对请求资源的访问被服务器拒绝"),r("br"),t._v("\n404：请求资源不存在"),r("br")]),t._v(" "),r("h4",{attrs:{id:"_5xx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5xx"}},[t._v("#")]),t._v(" 5XX")]),t._v(" "),r("p",[t._v("500：服务器处理请求时发生错误"),r("br"),t._v("\n501：服务器不支持当前请求的某个功能"),r("br"),t._v("\n503：服务器超负载或停机维护"),r("br")]),t._v(" "),r("h3",{attrs:{id:"http数据协商"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http数据协商"}},[t._v("#")]),t._v(" Http数据协商")]),t._v(" "),r("p",[t._v("客户端发送请求时，会声明可以接收的数据格式和相关的限制；服务端在接收时会根据这个信息判断返回怎样的数据")]),t._v(" "),r("h4",{attrs:{id:"请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#请求"}},[t._v("#")]),t._v(" 请求")]),t._v(" "),r("p",[t._v("Accept： 申明想要的数据格式"),r("br"),t._v("\nAccept-Encoding：告诉服务端以怎样的方式来压缩(如gzip)"),r("br"),t._v("\nAccept-language：描述语言信息"),r("br"),t._v("\nUser-Agent：描述客户端浏览器相关信息，可以用来区分PC端和移动端页面"),r("br")]),t._v(" "),r("h4",{attrs:{id:"响应"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#响应"}},[t._v("#")]),t._v(" 响应")]),t._v(" "),r("p",[t._v("Content-Type: 对应Accept，服务端返回数据类型(从请求中的Accept选一种来返回)"),r("br"),t._v("\nContent-Encoding: 对应Accept-Encoding，指服务器使用哪种压缩方式"),r("br"),t._v("\nContent-Language：对应Accept-language"),r("br")]),t._v(" "),r("h3",{attrs:{id:"http2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),r("p",[t._v("HTTP2相较于HTTP1，大幅提高了web的性能"),r("br"),t._v("\nHTTP2采用二进制格式传输，并且提供了乱序传递，替代了HTTP1的文本格式，二进制的格式解析更为高效"),r("br")]),t._v(" "),r("p",[t._v("多路复用代替了HTTP1的序列和阻塞机制，所有在相同域名下的请求都通过一个TCP连接并发完成"),r("br"),t._v("\nHTTP2中有两个概念，帧和流，帧代表最小的数据单位，每个帧上会表示出属于哪个流"),r("br"),t._v("\n多路复用，就是一个TCP连接中可以存在多条流，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免HTTP旧版本队头阻塞的问题。"),r("br")]),t._v(" "),r("p",[t._v("Header压缩：在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。"),r("br")]),t._v(" "),r("h3",{attrs:{id:"https"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),r("h4",{attrs:{id:"对称加密"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),r("p",[t._v("对称加密又称私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。"),r("br"),t._v("\n对称加密的特点是算法公开，加密和解密速度快，适合于对大数据量进行加密。"),r("br")]),t._v(" "),r("h4",{attrs:{id:"非对称加密"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),r("p",[t._v("非对称加密也叫作公钥加密。安全性更好。"),r("br"),t._v("\n对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。"),r("br"),t._v("\n非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。\n用公钥或私钥中的任何一个进行加密，另一个进行解密。"),r("br"),t._v("\n非对称加密的缺点是加密和解密花费时间长，速度慢，只适合对少量数据进行加密。"),r("br")]),t._v(" "),r("p",[t._v("HTTPS协议 = HTTP协议 + SSL/TLS协议。在HTTPS数据传输过程中，需要SSL/TLS对数据进行加密和解密，由HTTP传输。"),r("br"),t._v("\nHTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。"),r("br"),t._v("\n对传输数据进行对称加密，对称加密所要用的密钥通过非对称加密传输"),r("br")]),t._v(" "),r("p",[t._v("HTTPS传输过程：\n一个HTTPS请求实际上包含了两次HTTP传输，可以分为8步："),r("br"),t._v("\n1.客户端向服务端发起HTTPS请求，连接到服务器的443端口。"),r("br"),t._v("\n2.服务端有一个密钥对，即公钥和私钥，服务端保存着私钥，不将其泄露，公钥可以发送给任何人。"),r("br"),t._v("\n3.服务器把公钥发给客户端。"),r("br"),t._v("\n4.客户端接收到公钥，并验证其合法性。然后随机生成一个私钥，用服务端公钥对其进行加密。"),r("br"),t._v("\n4.客户端把加密后的客户端私钥发给服务端。"),r("br"),t._v("\n5.服务端用服务端私钥对接收的密文进行非对称解密，拿到客户端私钥。"),r("br"),t._v("\n6.用客户端私钥对传输数据进行加密。"),r("br"),t._v("\n7.返回加密数据。"),r("br"),t._v("\n8.客户端接收到密文，用客户端私钥进行对称解密，得到服务端发送的数据"),r("br")]),t._v(" "),r("h3",{attrs:{id:"cookie-localstorage-sessionstorage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cookie-localstorage-sessionstorage"}},[t._v("#")]),t._v(" cookie localStorage sessionStorage")]),t._v(" "),r("h4",{attrs:{id:"cookie"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" cookie:")]),t._v(" "),r("p",[t._v("服务器通过设置 set-cookie 这个响应头，将cookie信息返回给浏览器。"),r("br"),t._v("\n浏览器将响应头中的cookie信息保存在本地，下次向服务器发起请求时（同源请求），浏览器会自动将保存的这些cookie信息添加到请求头中。"),r("br"),t._v("\n服务器通过cookie信息判断用户的信息、状态。")]),t._v(" "),r("ul",[r("li",[t._v("通过set-cookie设置")]),t._v(" "),r("li",[t._v("下次请求会自动带上")]),t._v(" "),r("li",[t._v("键值对，可设置多个")])]),t._v(" "),r("h5",{attrs:{id:"cookie属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cookie属性"}},[t._v("#")]),t._v(" cookie属性")]),t._v(" "),r("ul",[r("li",[t._v("max-age\n"),r("ul",[r("li",[t._v("有效时间（默认在浏览器关闭时失效）")])])]),t._v(" "),r("li",[t._v("expires\n"),r("ul",[r("li",[t._v("过期时间点")])])]),t._v(" "),r("li",[t._v("secure\n"),r("ul",[r("li",[t._v("表示这个cookie只会在https请求的时候才会发送")])])]),t._v(" "),r("li",[t._v("HttpOnly\n"),r("ul",[r("li",[t._v("设置后无法在js中通过document.cookie访问")])])]),t._v(" "),r("li",[t._v("domain\n"),r("ul",[r("li",[t._v("表示cookie对于哪个域是有效的")])])])]),t._v(" "),r("h5",{attrs:{id:"session与cookie的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#session与cookie的区别"}},[t._v("#")]),t._v(" session与cookie的区别")]),t._v(" "),r("ul",[r("li",[t._v("session保存在服务端，cookie保存在客户端。")]),t._v(" "),r("li",[t._v("session 有对应的sessionId，sessionId存储在cookie中。每次访问服务端从cookie中取出sessionId，再拿到对应的session信息。")]),t._v(" "),r("li",[t._v("session会消耗服务器资源。cookie在每次http请求都会带上，影响网络性能。")]),t._v(" "),r("li",[t._v("域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用。")])]),t._v(" "),r("h3",{attrs:{id:"localstorage-sessionstorage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-sessionstorage"}},[t._v("#")]),t._v(" localStorage/sessionStorage")]),t._v(" "),r("ul",[r("li",[t._v("localStorage/sessionStorage仅在本地保存，不会自动发送给服务器。")]),t._v(" "),r("li",[t._v("cookie数据大小不超过4k，localStorage/sessionStorage 能达到5M。")]),t._v(" "),r("li",[t._v("sessionStorage 在浏览器标签关闭后自动删除，localStorage若没有设置过期时间则永久有效。")])]),t._v(" "),r("h2",{attrs:{id:"浏览器缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),r("p",[t._v("###强制缓存\n当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中，和请求结果一起返回给浏览器。"),r("br"),t._v("\n控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级更高。"),r("br")]),t._v(" "),r("h4",{attrs:{id:"expires"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),r("p",[t._v("Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。"),r("br"),t._v("\n到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，\n那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，\n这样的话强制缓存的存在则毫无意义。"),r("br")]),t._v(" "),r("h4",{attrs:{id:"cache-control"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),r("ul",[r("li",[t._v("public: 所有内容都将被缓存(客户端和代理服务器都可缓存)")]),t._v(" "),r("li",[t._v("private: 所有内容只有客户端可以缓存。(Cache-Control的默认值)")]),t._v(" "),r("li",[t._v("no-cache: 客户端缓存内容，但是否使用缓存需要协商缓存来验证决定。")]),t._v(" "),r("li",[t._v("no-store: 所有内容都不会被缓存，既不使用强制缓存，也不使用协商缓存。")]),t._v(" "),r("li",[t._v("max-age=xxx: 缓存内容将在xxx秒后失效")])]),t._v(" "),r("p",[t._v("####缓存存放位置\n在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，\n那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；\n而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。")]),t._v(" "),r("p",[t._v("###协商缓存\n协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。主要有两种情况："),r("br")]),t._v(" "),r("ol",[r("li",[t._v("服务端返回304，协商缓存生效。"),r("br")]),t._v(" "),r("li",[t._v("服务端返回200，协商缓存失败。"),r("br")])]),t._v(" "),r("p",[t._v("协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，\n控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，\n其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。"),r("br")]),t._v(" "),r("h4",{attrs:{id:"last-modified-if-modified-since"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[t._v("#")]),t._v(" Last-Modified / If-Modified-Since")]),t._v(" "),r("p",[t._v("Last-Modified是服务器响应请求时，返回该资源文件在服务器中最后被修改的时间。"),r("br"),t._v("\nIf-Modified-Since 则是客户端再次发起请求时，放在请求头的上次Last-Modified的值。"),r("br"),t._v("\n服务端拿到If-Modified-Since 与该资源最后被修改时间做对比，如果时间大于If-Modified-Since的值，则重新返回资源，状态码为200.\n否则返回状态码304，表示资源没有更新，可以继续使用缓存文件。")]),t._v(" "),r("h4",{attrs:{id:"etag-if-none-match"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" Etag / If-None-Match")]),t._v(" "),r("p",[t._v("Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)"),r("br"),t._v("\nIf-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。\n服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比。\n一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。")]),t._v(" "),r("h2",{attrs:{id:"跨域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),r("h4",{attrs:{id:"同源策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同源策略"}},[t._v("#")]),t._v(" 同源策略")]),t._v(" "),r("ul",[r("li",[t._v("域名相同")]),t._v(" "),r("li",[t._v("端口相同")]),t._v(" "),r("li",[t._v("协议相同")])]),t._v(" "),r("p",[t._v("作用：浏览器为了保证用户信息安全，防止恶意网站窃取数据。")]),t._v(" "),r("h4",{attrs:{id:"同源策略限制范围"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同源策略限制范围"}},[t._v("#")]),t._v(" 同源策略限制范围")]),t._v(" "),r("ul",[r("li",[t._v("Dom无法获取")]),t._v(" "),r("li",[t._v("ajax请求不能发送")]),t._v(" "),r("li",[t._v("cookie，localStorage无法获取")])]),t._v(" "),r("h3",{attrs:{id:"cors"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cors"}},[t._v("#")]),t._v(" CORS")]),t._v(" "),r("p",[t._v("当发起一个跨域的ajax请求，浏览器会在请求头加一个origin字段。"),r("br"),t._v("\n服务端在响应头中添加 'Access-Control-Allow-Origin' 就可以开启CORS。\n该属性表示哪些域名可以访问返回的资源，如果设置通配符表示所有网站都可以访问资源。\n如果'Access-Control-Allow-Origin'中没有对应网址或 * ，那么浏览器就回把返回的内容忽略掉，并在控制台报错。")]),t._v(" "),r("p",[t._v("CORS分为简单请求和复杂请求。")]),t._v(" "),r("h4",{attrs:{id:"简单请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单请求"}},[t._v("#")]),t._v(" 简单请求")]),t._v(" "),r("p",[t._v("请求方法为其中之一： "),r("br")]),t._v(" "),r("ul",[r("li",[t._v("GET")]),t._v(" "),r("li",[t._v("POST")]),t._v(" "),r("li",[t._v("HEAD")])]),t._v(" "),r("p",[t._v("Content-Type为其中之一：")]),t._v(" "),r("ul",[r("li",[t._v("text/plain")]),t._v(" "),r("li",[t._v("multipart/form-data")]),t._v(" "),r("li",[t._v("application/x-www-form-urlencoded")])]),t._v(" "),r("p",[t._v("其他类型的请求方法和Content-Type 需要通过预检请求验证后才能发送")]),t._v(" "),r("h4",{attrs:{id:"cors预检请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cors预检请求"}},[t._v("#")]),t._v(" CORS预检请求")]),t._v(" "),r("p",[t._v("规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先用OPTIONS方法发起一个预检请求。"),r("br"),t._v("\n服务器在响应头中加入允许请求的方法和Content-Type。"),r("br"),t._v("\n若发起的'复杂请求'被允许，就可以成功发起请求了"),r("br")]),t._v(" "),r("h3",{attrs:{id:"jsonp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[t._v("#")]),t._v(" jsonp")]),t._v(" "),r("p",[t._v("利用script标签，link标签，img标签，iframe标签来进行跨域请求\nJSONP的原理：")]),t._v(" "),r("ul",[r("li",[t._v("创建一个script标签，src是请求的地址")]),t._v(" "),r("li",[t._v("script放入DOM中，会自动请求服务端")]),t._v(" "),r("li",[t._v("服务端接收请求，返回约定好的一段文本（执行某个回调函数）")]),t._v(" "),r("li",[t._v("返回的文本放在script中，浏览器会执行它")]),t._v(" "),r("li",[t._v("这个文本刚好是函数调用的形式，浏览器把它当做JS代码来调用这个函数")])]),t._v(" "),r("h3",{attrs:{id:"postmessage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#postmessage"}},[t._v("#")]),t._v(" postMessage")]),t._v(" "),r("p",[t._v("// 窗口A中           "),r("br"),t._v("\nwindow.postMessage('data', 'http://A.com');   "),r("br"),t._v("\n// 窗口B中            "),r("br"),t._v("\nwindow.addEventListener('message', function(event) {   "),r("br"),t._v("\nconsole.log(event.origin);    // http://A.com       "),r("br"),t._v("\nconsole.log(event.source);    // A 对象window引用    "),r("br"),t._v("\nconsole.log(event.data);      // 数据                "),r("br"),t._v("\n})")]),t._v(" "),r("h3",{attrs:{id:"websocket"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" WebSocket")]),t._v(" "),r("h3",{attrs:{id:"document-domain"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#document-domain"}},[t._v("#")]),t._v(" document.domain")]),t._v(" "),r("p",[t._v("该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。"),r("br")]),t._v(" "),r("p",[t._v("只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域。 "),r("br")])])}),[],!1,null,null,null);a.default=v.exports}}]);